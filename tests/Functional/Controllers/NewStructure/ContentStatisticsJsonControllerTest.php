<?php

namespace Railroad\Railcontent\Tests\Functional\Controllers\NewStructure;

use Carbon\Carbon;
use Railroad\Railcontent\Services\ContentService;
use Railroad\Railcontent\Services\ContentStatisticsService;
use Railroad\Railcontent\Tests\RailcontentTestCase;

class ContentJsonControllerTest extends RailcontentTestCase
{
    /**
     * @var ContentStatisticsService
     */
    private $contentStatisticsService;

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->contentStatisticsService = $this->app->make(ContentStatisticsService::class);
    }

    public function test_content_statistics()
    {
        // random date, between 16 and 30 days ago
        $testSmallDate = Carbon::now()->subDays($this->faker->numberBetween(16, 30));

        // random date, between 5 and 15 days ago
        $testBigDate = Carbon::now()->subDays($this->faker->numberBetween(5, 15));

        $testIntervalSmallDate = $testSmallDate->copy()->subDays($testSmallDate->dayOfWeek)->startOfDay();
        $testIntervalBigDate = $testBigDate->addDays(6 - $testBigDate->dayOfWeek)->endOfDay();

        // add content
        $contentData = [];

        for ($i=0; $i < 10; $i++) {
            $content = $this->fakeContent(1,[
                'type' => $this->faker->randomElement(config('railcontent.commentable_content_types')),
                'status' => ContentService::STATUS_PUBLISHED
            ])[0];

            $contentData[$content->getId()] = [
                'content_id' => $content->getId(),
                'content_type' => $content->getType(),
                'content_published_on' => $content->getPublishedOn(),
                'content_brand' => $content->getBrand(),
                'content_title' => $content->getTitle(),
            ];
        }

        // content statistics seed intervals
        $intervals = $this->contentStatisticsService->getContentStatisticsIntervals(
            Carbon::now()->subDays($this->faker->numberBetween(35, 45)),
            Carbon::now()
        );

        $expectedStats = [];

        foreach ($intervals as $interval) {

            foreach ($contentData as $contentId => $content) {

                if (!$this->faker->randomElement([0, 1, 1, 1, 1])) {
                    // for 1 in 5 chance, do not add content stats, as in all stats should be 0
                    continue;
                }

                // generate random stats
                $contentStats = [
                    'completes' => $this->faker->numberBetween(0, 15),
                    'starts' => $this->faker->numberBetween(1, 15),
                    'comments' => $this->faker->numberBetween(0, 15),
                    'likes' => $this->faker->numberBetween(0, 15),
                    'added_to_list' => $this->faker->numberBetween(1, 15),
                    'start_interval' => $interval['start']->toDateTimeString(),
                    'end_interval' => $interval['end']->toDateTimeString(),
                    'week_of_year' => $interval['week'],
                    'content_published_on' => Carbon::now()->toDateTimeString(),
                    'created_on' => Carbon::now()->toDateTimeString(),
                ];

                $insertData = array_diff_key(
                        $content,
                        ['content_brand' => true, 'content_title' => true]
                    ) + $contentStats;

                $stats[] = $this->fakeContentStatistics($insertData);

                if (
                    $interval['start'] >= $testIntervalSmallDate
                    && $interval['start'] <= $testIntervalBigDate
                    && $interval['end'] >= $testIntervalSmallDate
                    && $interval['end'] <= $testIntervalBigDate
                ) {
                    if (!isset($expectedStats[$contentId])) {
                        $expectedStats[$contentId] = $content + [
                                'total_completes' => 0,
                                'total_starts' => 0,
                                'total_comments' => 0,
                                'total_likes' => 0,
                                'total_added_to_list' => 0,
                            ];
                    }

                    $expectedStats[$contentId]['total_completes'] += $contentStats['completes'];
                    $expectedStats[$contentId]['total_starts'] += $contentStats['starts'];
                    $expectedStats[$contentId]['total_comments'] += $contentStats['comments'];
                    $expectedStats[$contentId]['total_likes'] += $contentStats['likes'];
                    $expectedStats[$contentId]['total_added_to_list'] += $contentStats['added_to_list'];
                }
            }
        }

        $response = $this->call(
            'GET',
            'railcontent/content-statistics',
            [
                'small_date_time' => $testSmallDate->toDateTimeString(),
                'big_date_time' => $testBigDate->toDateTimeString(),
                'sort_by' => 'total_completes',
                'sort_dir' => 'desc',
            ]
        );

        $lastSortedByValue = -1;

        foreach ($response->decodeResponseJson('data') as $stats) {

            // assert stats value
            $this->assertEquals(
                $expectedStats[$stats['content_id']],
                $stats
            );

            // assert sorting
            if ($lastSortedByValue >= 0) {
                // each stats result, starting with second group, should have total_completes less or equal to previous group
                $this->assertTrue($lastSortedByValue >= $stats['total_completes']);
            }

            $lastSortedByValue = $stats['total_completes'];
        }
    }

}